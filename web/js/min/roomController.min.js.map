{"version":3,"sources":["web/js/roomController.js"],"names":["exports","debug","Utils","MultiLevelLogger","DEFAULT_LEVELS","all","otHelper","setPublisherReady","numUsrsInRoom","_disabledAllVideos","enableAnnotations","enableHangoutScroll","enableArchiveManager","enableSip","requireGoogleAuth","googleAuth","publisherReady","Promise","resolve","_sharedStatus","roomMuted","userName","window","roomURI","resolutionAlgorithm","debugPreferredResolution","token","publisherOptions","insertMode","width","height","showControls","resolution","publisherResolution","style","audioLevelDisplayMode","buttonDisplayMode","nameDisplayMode","videoDisabledDisplayMode","showArchiveStatus","subscriberOptions","camera","inserMode","screen","noVideo","SubscriberButtons","streamVideoType","phoneNumber","isScreenSharing","buttons","video","eventFiredName","dataIcon","eventName","context","action","enabled","audio","dialedNumberTokens","hangup","publisherButtons","subscriberStreams","processMutation","aMutation","elem","target","attributeName","data","streamId","subscriberPromise","then","subscriber","subscriberElem","dumpResolutionInfo","Object","keys","forEach","aSub","sub","stream","vd","videoDimensions","streamPref","getPreferredResolution","console","log","videoWidth","videoHeight","parent","parentNode","parentDimension","clientWidth","clientHeight","subsDimension","setPreferredResolution","sendVideoEvent","MutationObserver","aMutations","sendEvent","hasVideo","id","sendArchivingOperation","operation","roomName","Request","dialOut","some","isSip","name","googleIdToken","currentUser","get","getAuthResponse","id_token","roomStatusHandlers","[object Object]","RoomStatus","setAudioStatus","isJoining","pushSubscriberButton","status","viewEventHandlers","buttonClick","detail","disableAll","sendSignalMuteAll","onlyChangeSwitch","sendSignal","disconnect","url","location","origin","concat","href","evt","toggleSubscribersVideo","info","value","prevEnabled","getStatus","streamType","switchStatus","buttonInfo","args","newStatus","isPublisher","isPublisherReady","publisherHas","error","hangUp","push","sendStatus","isMicrophone","isSubscribeToVideo","aStreamId","videoType","replace","isSignedIn","signIn","document","body","orientation","navigator","share","title","catch","selector","Modal","show","enterButton","querySelector","addEventListener","onClicked","event","preventDefault","removeEventListener","inviteLinkBtn","getElementById","inputElem","textContent","clipboard","writeText","trim","innerText","originalText","setTimeout","hide","addClipBoardFeature","showAddToCallModal","hasAudio","togglePublisherAudio","togglePublisherVideo","state","sendLockingOperation","sendSignalLock","control","reason","_subscriberHandlers","_allHandlers","RoomView","participantsNumber","connectionData","JSON","parse","connection","sip","subOptions","enterWithVideoDisabled","subsDOMElem","createStreamView","type","controlElems","subscribeToVideo","subscribe","subContainer","element","parentElement","item","on","ResizeSensor","message","deleteStreamView","publisherId","changedProperty","newValue","signal:roomLocked","roomState","signal:muteAll","statusData","muteAllSwitch","setNewAudioStatus","isMuted","bind","undefined","isMyself","from","showConfirmChangeMicStatus","signal:archives","getRoomParams","RoomController","Error","pathName","pathname","split","length","decodeStr","params","parseSearch","search","usrId","getFirstValue","PrecallController","showCallSettingsPrompt","showRoom","publishAudio","publishVideo","audioSource","videoSource","getRoomInfo","aRoomParams","aRoomInfo","sessionId","apiKey","username","firebaseToken","firebaseURL","enableAnnotation","modules","init","LazyLoader","load","addEventsHandlers","OTHelper","aParams","loadAnnotations","OTKAnalytics","a","b","RecordingsController","substring","htmlEscape","sessionInfo","connect","room","GoogleAuth","googleId","googleHostedDomain","aGoogleAuth","ChatController","LayoutMenuController","maxUsersPerRoom","publisherElement","isIE","usePreviousDeviceSelection","publish","showPublisherButtons","errInfo","ScreenShareController","chromeExtId","FeedbackController","reportIssueLevel","PhoneNumberController","this"],"mappings":"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","sourcesContent":["/* global Utils, Request, RoomStatus, RoomView, LayoutManager, LazyLoader, Modal,\nChatController, GoogleAuth, LayoutMenuController, OTHelper, PrecallController,\nRecordingsController, ScreenShareController, FeedbackController,\nPhoneNumberController, ResizeSensor, maxUsersPerRoom */\n\n!(exports => {\n  const debug =\n    new Utils.MultiLevelLogger('roomController.js', Utils.MultiLevelLogger.DEFAULT_LEVELS.all);\n\n  let otHelper;\n  let numUsrsInRoom = 0;\n  let _disabledAllVideos = false;\n  let enableAnnotations = true;\n  let enableHangoutScroll = false;\n  let enableArchiveManager = false;\n  let enableSip = false;\n  let requireGoogleAuth = false; // For SIP dial-out\n  let googleAuth = null;\n\n  let setPublisherReady;\n  const publisherReady = new Promise(resolve => {\n    setPublisherReady = resolve;\n  });\n\n  const STATUS_KEY = 'room';\n  let _sharedStatus = {\n    roomMuted: false\n  };\n\n  let userName = window.userName;\n  let roomURI = null;\n  let resolutionAlgorithm = null;\n  let debugPreferredResolution = null;\n  let token = null;\n\n  const publisherOptions = {\n    insertMode: 'append',\n    width: '100%',\n    height: '100%',\n    showControls: true,\n    resolution: publisherResolution,\n    style: {\n      audioLevelDisplayMode: 'auto',\n      buttonDisplayMode: 'off',\n      nameDisplayMode: 'off',\n      videoDisabledDisplayMode: 'on',\n      showArchiveStatus: false\n    }\n  };\n\n  const subscriberOptions = {\n    camera: {\n      height: '100%',\n      width: '100%',\n      inserMode: 'append',\n      showControls: true,\n      style: {\n        audioLevelDisplayMode: 'auto',\n        buttonDisplayMode: 'off',\n        nameDisplayMode: 'off',\n        videoDisabledDisplayMode: 'auto',\n        showArchiveStatus: false\n      }\n    },\n    screen: {\n      height: '100%',\n      width: '100%',\n      inserMode: 'append',\n      showControls: false,\n      style: {\n        audioLevelDisplayMode: 'off',\n        buttonDisplayMode: 'off',\n        nameDisplayMode: 'on',\n        videoDisabledDisplayMode: 'off'\n      }\n    },\n    noVideo: {\n      height: '100%',\n      width: '100%',\n      inserMode: 'append',\n      showControls: true,\n      style: {\n        audioLevelDisplayMode: 'auto',\n        buttonDisplayMode: 'off',\n        nameDisplayMode: 'on',\n        videoDisabledDisplayMode: 'off'\n      }\n    }\n  };\n\n  const isMobile = () => { return typeof window.orientation !== 'undefined'; };\n\n  const SubscriberButtons = (streamVideoType, phoneNumber) => {\n    const isScreenSharing = streamVideoType === 'screen';\n\n    const buttons = { };\n\n    if (!phoneNumber) {\n      buttons.video = {\n        eventFiredName: 'roomView:buttonClick',\n        dataIcon: isScreenSharing ? 'desktop' : 'video',\n        eventName: 'click',\n        context: 'otHelper',\n        action: 'toggleSubscribersVideo',\n        enabled: true\n      };\n    }\n\n    if (!isScreenSharing) {\n      buttons.audio = {\n        eventFiredName: 'roomView:buttonClick',\n        dataIcon: 'audio',\n        eventName: 'click',\n        context: 'otHelper',\n        action: 'toggleSubscribersAudio',\n        enabled: true\n      };\n    }\n    if (phoneNumber && (phoneNumber in dialedNumberTokens)) {\n      buttons.hangup = {\n        eventFiredName: 'roomView:buttonClick',\n        dataIcon: 'hangup',\n        eventName: 'click',\n        context: 'otHelper',\n        action: 'hangup',\n        enabled: true\n      };\n    }\n\n    return buttons;\n  };\n\n  const publisherButtons = {\n    video: {\n      eventFiredName: 'roomView:buttonClick',\n      dataIcon: 'video',\n      eventName: 'click',\n      context: 'otHelper',\n      action: 'togglePublisherVideo',\n      enabled: true\n    },\n    audio: {\n      eventFiredName: 'roomView:buttonClick',\n      dataIcon: 'mic',\n      eventName: 'click',\n      context: 'otHelper',\n      action: 'togglePublisherAudio',\n      enabled: true\n    }\n  };\n\n  let subscriberStreams = { };\n  var dialedNumberTokens = {};\n\n  // We want to use media priorization on the subscriber streams. We're going to restrict the\n  // maximum width and height to the one that's actually displayed. To do that, we're going to\n  // observe changes on the elements that hold the subscribers.\n  // Note that mutationObserver only works on IE11+, but that the previous alternative doesn't\n  // work all that well either.\n  const processMutation = aMutation => {\n    const elem = aMutation.target;\n    if ((aMutation.attributeName !== 'style' && aMutation.attributeName !== 'class') ||\n        elem.data('streamType') !== 'camera') {\n      return;\n    }\n    const streamId = elem.data('id');\n    const subscriberPromise =\n      subscriberStreams[streamId] && subscriberStreams[streamId].subscriberPromise;\n\n    subscriberPromise.then(subscriber => {\n      if (debugPreferredResolution) {\n        // If the user requested debugging this, we're going to export all the information through\n        // window so he can examine the values.\n        window.subscriberElem = window.subscriberElem || {};\n        window.subscriberElem[streamId] = elem;\n        window.subscriber = window.subscriber || {};\n        window.subscriber[streamId] = subscriber;\n        window.dumpResolutionInfo = window.dumpResolutionInfo || (() => {\n          Object.keys(window.subscriber)\n            .forEach(aSub => {\n              const sub = window.subscriber[aSub];\n              const stream = sub && sub.stream;\n              const vd = stream && stream.videoDimensions;\n              const streamPref = (stream && stream.getPreferredResolution()) ||\n                                 { width: 'NA', height: 'NA' };\n              stream && console.log( // eslint-disable-line no-console\n                'StreamId:', aSub, 'Real:', sub.videoWidth(), 'x', sub.videoHeight(),\n                'Stream.getPreferredResolution:', streamPref.width, 'x', streamPref.height,\n                'Stream.VDimension:', vd.width, 'x', vd.height\n              );\n            });\n        });\n      }\n\n      const parent = elem.parentNode;\n\n      const parentDimension = {\n        width: parent.clientWidth,\n        height: parent.clientHeight\n      };\n      const subsDimension = {\n        width: elem.clientWidth,\n        height: elem.clientHeight\n      };\n      otHelper.setPreferredResolution(subscriber, parentDimension, subsDimension, numUsrsInRoom - 1,\n        resolutionAlgorithm);\n    });\n  };\n  const _mutationObserver = exports.MutationObserver &&\n    new exports.MutationObserver(aMutations => {\n      aMutations.forEach(processMutation);\n    });\n\n  const sendVideoEvent = stream => {\n    if (!stream) {\n      return;\n    }\n\n    Utils.sendEvent(`roomController:${stream.hasVideo ? 'videoEnabled' : 'videoDisabled'}`, {\n      id: stream.streamId\n    });\n  };\n\n  const sendArchivingOperation = operation => {\n    const data = {\n      userName,\n      roomName: roomURI,\n      operation\n    };\n\n    Request.sendArchivingOperation(data);\n  };\n\n  const dialOut = phoneNumber => {\n    const alreadyInCall = Object.keys(subscriberStreams)\n      .some(streamId => {\n        if (subscriberStreams[streamId]) {\n          const stream = subscriberStreams[streamId].stream;\n          return (stream.isSip && stream.name === phoneNumber);\n        }\n        return false;\n      });\n\n    if (alreadyInCall) {\n      console.log(`The number is already in this call: ${phoneNumber}`); // eslint-disable-line no-console\n    } else {\n      let googleIdToken;\n      if (requireGoogleAuth) {\n        const user = googleAuth.currentUser.get();\n        googleIdToken = user.getAuthResponse().id_token;\n      } else {\n        googleIdToken = '';\n      }\n      const data = {\n        phoneNumber,\n        googleIdToken\n      };\n      Request.dialOut(roomURI, data);\n      dialedNumberTokens[phoneNumber] = googleIdToken;\n    }\n  };\n\n  const hangup = streamId => {\n    if (!subscriberStreams[streamId]) {\n      return;\n    }\n    const stream = subscriberStreams[streamId].stream;\n    if (!stream.isSip) {\n      return;\n    }\n    const phoneNumber = stream.phoneNumber;\n    if (!(phoneNumber in dialedNumberTokens)) {\n      return;\n    }\n    const token = dialedNumberTokens[phoneNumber];\n    Request.hangUp(phoneNumber, token);\n    delete dialedNumberTokens[phoneNumber];\n  };\n\n  const roomStatusHandlers = {\n    updatedRemotely() {\n      publisherReady.then(() => {\n        _sharedStatus = RoomStatus.get(STATUS_KEY);\n        const roomMuted = _sharedStatus.roomMuted;\n        setAudioStatus(roomMuted);\n        roomMuted && Utils.sendEvent('roomController:roomMuted', { isJoining: true });\n      });\n    }\n  };\n\n  const changeSubscriberStatus = (name, status) => {\n    _disabledAllVideos = status;\n\n    Object.keys(subscriberStreams).forEach(aStreamId => {\n      if (subscriberStreams[aStreamId] &&\n          subscriberStreams[aStreamId].stream.videoType === 'camera') {\n        pushSubscriberButton(aStreamId, name, status);\n      }\n    });\n  };\n\n  var pushSubscriberButton = (streamId, name, status) => {\n    viewEventHandlers.buttonClick({\n      detail: {\n        streamId,\n        name,\n        disableAll: true,\n        status\n      }\n    });\n  };\n\n  function sendSignalMuteAll(status, onlyChangeSwitch) {\n    otHelper.sendSignal('muteAll', { status, onlyChangeSwitch });\n  }\n\n  function sendSignalLock(status) {\n    otHelper.sendSignal('roomLocked', { status });\n  }\n\n  var viewEventHandlers = {\n    endCall() {\n      otHelper.disconnect();\n      const url = window.location.origin.concat('/thanks');\n      window.location.href = url;\n\n    },\n    startArchiving(evt) {\n      sendArchivingOperation((evt.detail && evt.detail.operation) || 'startComposite');\n    },\n    stopArchiving() {\n      sendArchivingOperation('stop');\n    },\n    streamVisibilityChange(evt) {\n      const getStatus = info => {\n        let status = null;\n\n        if (evt.detail.value === 'hidden') {\n          info.prevEnabled = 'prevEnabled' in info ? info.prevEnabled : info.enabled;\n          status = false;\n        } else {\n          status = 'prevEnabled' in info ? info.prevEnabled : info.enabled;\n          delete info.prevEnabled;\n        }\n\n        return status;\n      };\n\n      const streamId = evt.detail.id;\n      if (streamId !== 'publisher') {\n        const stream = subscriberStreams[streamId];\n        stream && otHelper.toggleSubscribersVideo(stream.stream,\n          getStatus(stream.buttons.video));\n      }\n    },\n    buttonClick(evt) {\n      const streamId = evt.detail.streamId;\n      const streamType = evt.detail.streamType;\n      const name = evt.detail.name;\n      const disableAll = !!evt.detail.disableAll;\n      const switchStatus = evt.detail.status;\n      let buttonInfo = null;\n      const args = [];\n      let newStatus;\n      const isPublisher = streamId === 'publisher';\n\n      if (isPublisher) {\n        buttonInfo = publisherButtons[name];\n        newStatus = !buttonInfo.enabled;\n        // There are a couple of possible race conditions that would end on us not changing\n        // the status on the publisher (because it's already on that state).\n        if (!otHelper.isPublisherReady || otHelper.publisherHas(name) === newStatus) {\n          return;\n        }\n      } else {\n        const stream = subscriberStreams[streamId];\n        if (!stream) {\n          debug.error('Got an event from an nonexistent stream');\n          return;\n        }\n        if (name === 'hangup') {\n          hangup(streamId);\n          return;\n        }\n        buttonInfo = stream.buttons[name];\n        args.push(stream.stream);\n        newStatus = !buttonInfo.enabled;\n        // BUG xxxx - We don't receive videoDisabled/videoEnabled events when\n        // stopping/starting the screen sharing video\n        // OPENTOK-26021 - We don't receive any event when mute/unmute the audio in local streams\n        if (streamType === 'screen' || name === 'audio') {\n          // so we assume the operation was performed properly and change the UI status\n          sendStatus({ stream: stream.stream }, name, newStatus);\n        }\n      }\n\n      if (!buttonInfo) {\n        debug.error('Got an event from an unknown button!');\n        return;\n      }\n\n      args.push(newStatus);\n\n      if (!disableAll || (disableAll && (switchStatus !== newStatus))) {\n        const obj = exports[buttonInfo.context];\n        obj[buttonInfo.action](...args);\n        // if stream button clicked and isn't a screen\n        if (!disableAll && streamType !== 'screen') {\n          // If type = 'audio'\n          //   it only has to propagate the change when the button clicked is the microphone\n          // if type = 'video'\n          //   only when button clicked is not the publisher's one (is a subscriber's video button)\n          // it type = 'screen'\n          //   don't do anything\n          const isMicrophone = name === 'audio' && isPublisher;\n          const isSubscribeToVideo = name === 'video' && !isPublisher;\n          if (isMicrophone || isSubscribeToVideo) {\n            Utils.sendEvent('roomController:userChangeStatus', { status: newStatus, name });\n            if (isMicrophone) {\n              sendSignalMuteAll(false, true);\n              _sharedStatus.roomMuted = false;\n            }\n          }\n        }\n      }\n    },\n    videoSwitch(evt) {\n      changeSubscriberStatus('video', evt.detail.status);\n    },\n    muteAllSwitch(evt) {\n      const roomMuted = evt.detail.status;\n      _sharedStatus.roomMuted = roomMuted;\n      setAudioStatus(roomMuted);\n      sendSignalMuteAll(roomMuted, false);\n    },\n    dialOut(evt) {\n      if (evt.detail) {\n        const phoneNumber = evt.detail.replace(/\\D/g, '');\n        if (requireGoogleAuth && (googleAuth.isSignedIn.get() !== true)) {\n          googleAuth.signIn().then(() => {\n            document.body.data('google-signed-in', 'true');\n            dialOut(phoneNumber);\n          });\n        } else {\n          dialOut(phoneNumber);\n        }\n      }\n    },\n    addToCall() {\n      if (isMobile() && navigator.share) {\n        showMobileShareUrl();\n      } else {\n        showAddToCallModal();\n      }\n    },\n    togglePublisherAudio(evt) {\n      const newStatus = evt.detail.hasAudio;\n      if (!otHelper.isPublisherReady || otHelper.publisherHas('audio') !== newStatus) {\n        otHelper.togglePublisherAudio(newStatus);\n      }\n    },\n    togglePublisherVideo(evt) {\n      const newStatus = evt.detail.hasVideo;\n      if (!otHelper.isPublisherReady || otHelper.publisherHas('video') !== newStatus) {\n        otHelper.togglePublisherVideo(newStatus);\n      }\n    },\n    setRoomLockState(evt) {\n      const state = evt.detail;\n      const data = {\n        userName,\n        token,\n        state,\n        roomURI\n      };\n\n      Request.sendLockingOperation(data).then(() => sendSignalLock(state));\n    }\n  };\n\n  var setAudioStatus = switchStatus => {\n    otHelper.isPublisherReady && viewEventHandlers.buttonClick({\n      detail: {\n        streamId: 'publisher',\n        name: 'audio',\n        disableAll: true,\n        status: switchStatus\n      }\n    });\n  };\n\n  var sendStatus = (evt, control, enabled) => {\n    let stream = evt.stream || evt.target.stream;\n    if (!stream) {\n      return;\n    }\n\n    const id = stream.streamId;\n    stream = subscriberStreams[id];\n    const buttonInfo = !stream ? publisherButtons[control] : stream.buttons[control];\n    buttonInfo.enabled = !!enabled;\n\n    Utils.sendEvent(`roomController:${control}`, {\n      id,\n      reason: evt.reason,\n      enabled: buttonInfo.enabled\n    });\n  };\n\n  const _subscriberHandlers = {\n    videoDisabled(evt) {\n      evt.reason === 'subscribeToVideo' && sendStatus(evt, 'video');\n      sendVideoEvent(evt.target.stream);\n    },\n    videoEnabled(evt) {\n      evt.reason === 'subscribeToVideo' && sendStatus(evt, 'video', true);\n      sendVideoEvent(evt.target.stream);\n    },\n    disconnected(evt) {\n      Utils.sendEvent('roomController:disconnected', {\n        id: evt.target.stream.streamId\n      });\n    },\n    connected(evt) {\n      Utils.sendEvent('roomController:connected', {\n        id: evt.target.stream.streamId\n      });\n    }\n  };\n\n  let _allHandlers = {\n    connectionCreated() {\n      RoomView.participantsNumber = ++numUsrsInRoom;\n    },\n    connectionDestroyed() {\n      RoomView.participantsNumber = --numUsrsInRoom;\n    },\n    sessionConnected() {\n      Utils.sendEvent('roomController:sessionConnected');\n    },\n    sessionDisconnected() {\n      // The client has disconnected from the session.\n      // This event may be dispatched asynchronously in response to a successful\n      // call to the disconnect() method of the Session object.\n      // The event may also be disptached if a session connection is lost\n      // inadvertantly, as in the case of a lost network connection.\n      numUsrsInRoom = 0;\n      Utils.sendEvent('roomController:sessionDisconnected');\n      subscriberStreams = {};\n    },\n    streamCreated(evt) {\n      publisherReady.then(() => {\n        // A new stream, published by another client, has been created on this\n        // session. For streams published by your own client, the Publisher object\n        // dispatches a streamCreated event. For a code example and more details,\n        // see StreamEvent.\n        const stream = evt.stream;\n        // SIP call streams have no video.\n        const streamVideoType = stream.videoType || 'noVideo';\n\n        let connectionData;\n        try {\n          connectionData = JSON.parse(stream.connection.data);\n        } catch (error) {\n          connectionData = {};\n        }\n        // Add an isSip flag to stream object\n        stream.isSip = !!connectionData.sip;\n        if (!stream.name) {\n          stream.name = connectionData.name || '';\n        }\n\n        const streamId = stream.streamId;\n        stream.phoneNumber = stream.isSip && stream.name;\n        if (stream.isSip) {\n          stream.name = 'Invited Participant';\n        }\n\n        subscriberStreams[streamId] = {\n          stream,\n          buttons: SubscriberButtons(streamVideoType, stream.phoneNumber)\n        };\n\n        const subOptions = subscriberOptions[streamVideoType];\n        const enterWithVideoDisabled = streamVideoType === 'camera' && _disabledAllVideos;\n\n        _sharedStatus = RoomStatus.get(STATUS_KEY);\n\n        const subsDOMElem = RoomView.createStreamView(streamId, {\n          name: stream.name,\n          type: stream.videoType,\n          controlElems: subscriberStreams[streamId].buttons\n        });\n\n        subOptions.subscribeToVideo = !enterWithVideoDisabled;\n\n        /* Use ResizeSensor instead of mutationObserver\n        // We want to observe the container where the actual suscriber will live\n        var subsContainer = LayoutManager.getItemById(streamId);\n        subsContainer && _mutationObserver &&\n          _mutationObserver.observe(subsContainer, { attributes: true });\n        */\n\n        subscriberStreams[streamId].subscriberPromise =\n          otHelper.subscribe(evt.stream, subsDOMElem, subOptions, {}, enableAnnotations)\n            .then(subscriber => {\n              if (streamVideoType === 'screen') {\n                enableAnnotations && Utils.sendEvent('roomController:annotationStarted');\n                const subContainer = subscriber.element.parentElement;\n                Utils.sendEvent('layoutView:itemSelected', {\n                  item: subContainer\n                });\n                return subscriber;\n              }\n\n              Object.keys(_subscriberHandlers).forEach(name => {\n                subscriber.on(name, _subscriberHandlers[name]);\n              });\n              if (enterWithVideoDisabled) {\n                pushSubscriberButton(streamId, 'video', true);\n              }\n\n              new ResizeSensor(subsDOMElem, () => { // eslint-disable-line no-new\n                const subsDimension = {\n                  width: subsDOMElem.clientWidth,\n                  height: subsDOMElem.clientHeight\n                };\n                otHelper.setPreferredResolution(subscriber, null, subsDimension, null, null);\n              });\n\n              sendVideoEvent(evt.stream);\n              return subscriber;\n            }, error => {\n              debug.error(`Error susbscribing new participant. ${error.message}`);\n            });\n      });\n    },\n    streamDestroyed(evt) {\n      // A stream from another client has stopped publishing to the session.\n      // The default behavior is that all Subscriber objects that are subscribed\n      // to the stream are unsubscribed and removed from the HTML DOM. Each\n      // Subscriber object dispatches a destroyed event when the element is\n      // removed from the HTML DOM. If you call the preventDefault() method in\n      // the event listener for the streamDestroyed event, the default behavior\n      // is prevented and you can clean up Subscriber objects using your own\n      // code. See Session.getSubscribersForStream().\n      // For streams published by your own client, the Publisher object\n      // dispatches a streamDestroyed event.\n      // For a code example and more details, see StreamEvent.\n      const stream = evt.stream;\n      if (stream.videoType === 'screen') {\n        Utils.sendEvent('roomController:annotationEnded');\n      }\n      RoomView.deleteStreamView(stream.streamId);\n      subscriberStreams[stream.streamId] = null;\n    },\n    streamPropertyChanged(evt) {\n      if (otHelper.publisherId !== evt.stream.id) {\n        return;\n      }\n      if (evt.changedProperty === 'hasVideo') {\n        evt.reason = 'publishVideo';\n        sendStatus(evt, 'video', evt.newValue);\n      } else if (evt.changedProperty === 'hasAudio') {\n        evt.reason = 'publishAudio';\n        sendStatus(evt, 'audio', evt.newValue);\n      }\n    },\n    archiveStarted(evt) {\n      // Dispatched when an archive recording of the session starts\n      Utils.sendEvent('archiving', {\n        status: 'started',\n        id: evt.id\n      });\n    },\n    archiveStopped() {\n      // Dispatched when an archive recording of the session stops\n      Utils.sendEvent('archiving', { status: 'stopped' });\n    },\n    'signal:roomLocked': function (evt) {\n      const roomState = JSON.parse(evt.data).status;\n      Utils.sendEvent('roomController:roomLocked', roomState);\n    },\n    'signal:muteAll': function (evt) {\n      const statusData = JSON.parse(evt.data);\n      const muteAllSwitch = statusData.status;\n      const onlyChangeSwitch = statusData.onlyChangeSwitch;\n      // onlyChangeSwitch is true when the iOS app sends a false muteAll signal.\n      if (onlyChangeSwitch) {\n        return;\n      }\n\n      const setNewAudioStatus = (isMuted => {\n        if (_sharedStatus.roomMuted !== isMuted) {\n          return;\n        }\n        setAudioStatus(isMuted);\n      }).bind(undefined, muteAllSwitch);\n\n      if (!otHelper.isMyself(evt.from)) {\n        _sharedStatus.roomMuted = muteAllSwitch;\n        if (muteAllSwitch) {\n          setAudioStatus(muteAllSwitch);\n          Utils.sendEvent('roomController:roomMuted', { isJoining: false });\n        } else {\n          RoomView.showConfirmChangeMicStatus(muteAllSwitch).then(setNewAudioStatus);\n        }\n      }\n    },\n    'signal:archives': function (evt) {\n      Utils.sendEvent('roomController:archiveUpdates', evt);\n    }\n  };\n\n  function showMobileShareUrl() {\n    navigator.share({\n      title: 'Invite Participant',\n      url: location.href\n    })\n      .then(() => { console.log('Successful share'); })\n      .catch(error => { console.log('Error sharing', error); });\n  }\n\n  function addClipBoardFeature(selector) {\n    const inviteLinkBtn = document.getElementById('copyInviteLinkBtn');\n    const inputElem = document.getElementById('current-url');\n    if (inputElem && inputElem.textContent) {\n      navigator.clipboard.writeText(inputElem.textContent.trim())\n        .then(() => {\n          if (inviteLinkBtn.innerText !== 'Copied!') {\n            const originalText = inviteLinkBtn.innerText;\n            inviteLinkBtn.innerText = 'Copied!';\n            setTimeout(() => {\n              Modal.hide(selector);\n              inviteLinkBtn.innerText = originalText;\n            }, 2000);\n          }\n        });\n    }\n  }\n\n  function showAddToCallModal() {\n    const selector = '.add-to-call-modal';\n    return Modal.show(selector).then(() => {\n      return new Promise(resolve => {\n        const enterButton = document.querySelector(`${selector} button`);\n        enterButton && enterButton.addEventListener('click', function onClicked(event) {\n          event.preventDefault();\n          enterButton.removeEventListener('click', onClicked);\n          if (enterButton.id === 'copyInviteLinkBtn') {\n            addClipBoardFeature(selector);\n          } else {\n            Modal.hide(selector);\n          }\n          resolve();\n        });\n      });\n    });\n  }\n\n  function getRoomParams() {\n    if (!exports.RoomController) {\n      throw new Error('Room Controller is not defined. Missing script tag?');\n    }\n\n    // pathName should be /room/<roomURI>[?username=<userName>]\n    const pathName = document.location.pathname.split('/');\n\n    if (!pathName || pathName.length < 2) {\n      throw new Error('Invalid path');\n    }\n\n    let roomName = '';\n    let roomURI = '';\n    const length = pathName.length;\n    if (length > 0) {\n      roomURI = pathName[length - 1];\n    }\n    roomName = Utils.decodeStr(roomURI);\n\n    // Recover user identifier\n    const params = Utils.parseSearch(document.location.search);\n    const usrId = window.userName || params.getFirstValue('userName');\n    resolutionAlgorithm = params.getFirstValue('resolutionAlgorithm');\n    debugPreferredResolution = params.getFirstValue('debugPreferredResolution');\n    enableHangoutScroll = params.getFirstValue('enableHangoutScroll') !== undefined;\n\n    return PrecallController.showCallSettingsPrompt(roomName, usrId, otHelper)\n      .then(info => {\n        info.roomURI = roomURI;\n        RoomView.showRoom();\n        RoomView.roomURI = roomURI;\n        publisherOptions.publishAudio = info.publisherOptions.publishAudio;\n        publisherOptions.publishVideo = info.publisherOptions.publishVideo;\n        publisherOptions.audioSource = info.publisherOptions.audioSource;\n        publisherOptions.videoSource = info.publisherOptions.videoSource;\n        return info;\n      });\n  }\n\n  function getRoomInfo(aRoomParams) {\n    return Request\n      .getRoomInfo(aRoomParams)\n      .then(aRoomInfo => {\n        if (!(aRoomInfo && aRoomInfo.token && aRoomInfo.sessionId &&\n              aRoomInfo.apiKey && aRoomInfo.username) ||\n              (aRoomInfo.enableArchiveManager &&\n              (!aRoomInfo.firebaseToken || !aRoomInfo.firebaseURL))) {\n          debug.error('Error getRoomParams [', aRoomInfo,\n            '] without correct response');\n          throw new Error('Error getting room parameters');\n        }\n        aRoomInfo.roomURI = aRoomParams.roomURI;\n        aRoomInfo.publishAudio = aRoomParams.publishAudio;\n        aRoomInfo.publishVideo = aRoomParams.publishVideo;\n        enableAnnotations = aRoomInfo.enableAnnotation;\n        enableArchiveManager = aRoomInfo.enableArchiveManager;\n        enableSip = aRoomInfo.enableSip;\n        requireGoogleAuth = aRoomInfo.requireGoogleAuth;\n        return aRoomInfo;\n      });\n  }\n\n  const modules = [\n    '/js/components/htmlElems.js',\n    '/js/helpers/resolutionAlgorithms.js',\n    '/js/helpers/opentok-network-test.js',\n    '/js/itemsHandler.js',\n    '/js/layoutView.js',\n    '/js/layouts.js',\n    '/js/layoutManager.js',\n    '/js/roomView.js',\n    '/js/roomStatus.js',\n    '/js/min/chatController.min.js',\n    '/js/min/recordingsController.min.js',\n    '/js/min/precallController.min.js',\n    '/js/layoutMenuController.js',\n    '/js/min/screenShareController.min.js',\n    '/js/min/feedbackController.min.js',\n    '/js/googleAuth.js',\n    '/js/min/phoneNumberController.min.js',\n    '/js/vendor/ResizeSensor.js'\n  ];\n\n  const init = () => {\n    LazyLoader.load(modules)\n      .then(() => {\n        Utils.addEventsHandlers('roomView:', viewEventHandlers, exports);\n        Utils.addEventsHandlers('roomStatus:', roomStatusHandlers, exports);\n        Utils.addEventsHandlers('precallView:', {\n          submit() {\n          // Jeff to do: The room logic should go here, not in PrecallController.\n          }\n        });\n\n        return PrecallController.init();\n      })\n      .then(() => {\n        return LazyLoader.load('/js/helpers/OTHelper.js');\n      })\n      .then(() => {\n        otHelper = new OTHelper({});\n        exports.otHelper = otHelper;\n      })\n      .then(getRoomParams)\n      .then(getRoomInfo)\n      .then(aParams => {\n        let loadAnnotations = Promise.resolve();\n        if (enableAnnotations) {\n          exports.OTKAnalytics = exports.OTKAnalytics ||\n          (() => {\n            return {\n              addSessionInfo() {},\n              logEvent(a, b) {\n                console.log(a, b); // eslint-disable-line no-console\n              }\n            };\n          });\n\n          loadAnnotations = LazyLoader.load([\n            'https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js',\n            '/js/vendor/opentok-annotation.js'\n          ]);\n        }\n        return loadAnnotations.then(() => { return aParams; });\n      })\n      .then(aParams => {\n        RoomView.init(enableHangoutScroll, enableArchiveManager, enableSip);\n        // Init this controller before connect to the session\n        // to start receiving signals about archives updates\n        RecordingsController.init(enableArchiveManager);\n\n        roomURI = aParams.roomURI;\n        userName = aParams.username ? aParams.username.substring(0, 1000) : '';\n        userName = Utils.htmlEscape(userName.substring(0, 25));\n        token = aParams.token;\n\n        const sessionInfo = {\n          apiKey: aParams.apiKey,\n          sessionId: aParams.sessionId,\n          token: aParams.token\n        };\n\n        const connect = otHelper.connect.bind(otHelper, sessionInfo);\n\n        const waitForConnectionCount = () => {\n          return new Promise(resolve => {\n            if (!maxUsersPerRoom) {\n              return resolve();\n            }\n            return setTimeout(() => {\n              if (numUsrsInRoom > maxUsersPerRoom) {\n                Utils.sendEvent('roomController:meetingFullError');\n                return;\n              }\n              resolve();\n            }, 500);\n          });\n        };\n\n        RoomView.participantsNumber = 0;\n\n        _allHandlers = RoomStatus.init(_allHandlers, { room: _sharedStatus });\n\n        if (enableSip && requireGoogleAuth) {\n          GoogleAuth.init(aParams.googleId, aParams.googleHostedDomain, aGoogleAuth => {\n            googleAuth = aGoogleAuth;\n            if (googleAuth.isSignedIn.get()) {\n              document.body.data('google-signed-in', 'true');\n            }\n          });\n        }\n\n        ChatController\n          .init(userName, _allHandlers)\n          .then(connect)\n          .then(LayoutMenuController.init)\n          .then(waitForConnectionCount)\n          .then(() => {\n            const publisherElement = RoomView.createStreamView('publisher', {\n              name: userName,\n              type: 'publisher'\n            });\n            // If we have all audios disabled, we need to set the button status\n            // and don't publish audio\n            if (_sharedStatus.roomMuted) {\n            // Set visual status of button\n              sendStatus({\n                stream: {\n                  streamId: 'Publisher'\n                },\n                reason: 'publishAudio'\n              }, 'audio', false);\n              // Don't publish audio\n              publisherOptions.publishAudio = false;\n            }\n            publisherOptions.name = userName;\n            // Remember previous device selection in IE:\n            if (Utils.isIE()) {\n              publisherOptions.usePreviousDeviceSelection = true;\n            }\n            return otHelper.publish(publisherElement, publisherOptions, {}).then(() => {\n              setPublisherReady();\n              RoomView.showPublisherButtons(publisherOptions);\n            }).catch(errInfo => {\n              if (errInfo.error.name === 'OT_CHROME_MICROPHONE_ACQUISITION_ERROR') {\n                Utils.sendEvent('roomController:chromePublisherError');\n                otHelper.disconnect();\n              }\n            });\n          })\n          .then(() => {\n            ScreenShareController.init(userName, aParams.chromeExtId, otHelper, enableAnnotations);\n            FeedbackController.init(otHelper, aParams.reportIssueLevel);\n            PhoneNumberController.init();\n            Utils.sendEvent('roomController:controllersReady');\n          })\n          .catch(error => {\n            debug.error(`Error Connecting to room. ${error.message}`);\n          });\n      });\n  };\n\n  const RoomController = {\n    init\n  };\n\n  exports.RoomController = RoomController;\n})(this);\n"]}